package main

import (
	"github.com/Zargerion/Sync/sandbox"
)

func main() {
	syncInstance := sandbox.NewSync()

	////////////////////////////////////////////////
	// Ждет пока все потоки не завершат выполнение.
	// Может понадобиться для распараллеливаниея рендера.
	////////////////////////////////////////////////

	//syncInstance.RunWGExample(5)

	////////////////////////////////////////////////
	// Блокирует одно место в коде до конца взаимодействия
	// с одним из потоков. Потом пускает другой и т.д.
	// К примеру, для обращения в одно и тоже место БД.
	////////////////////////////////////////////////

	//syncInstance.RunMutexExample(15)

	////////////////////////////////////////////////
	// Гарантирует выполнение функции 1 раз даже в
	// многопотоке.
	// Хз, зачем юзать, если можно просто размещать
	// код для инициализации вне доп. горутин.
	////////////////////////////////////////////////

	//syncInstance.RunOnceExample()

	////////////////////////////////////////////////
	// Заставляет горутину ожидать изменения условя
	// для продолжения выполнения и сигнала об этом.
	// Не могу придумать что-то прикладное.
	////////////////////////////////////////////////

	//syncInstance.RunCondExample()

	////////////////////////////////////////////////
	// Заставляет горутину ожидать изменения условя
	// для продолжения выполнения и сигнала об этом.
	// Не могу придумать что-то прикладное.
	////////////////////////////////////////////////

	//syncInstance.RunRWMutexExample(7)

	////////////////////////////////////////////////
	// Лучше мютексов для простых опираций над числами.
	////////////////////////////////////////////////

	//syncInstance.RunAtomicExample()

	////////////////////////////////////////////////
	// Пайплайн обратотки эвентов на каналах...
	////////////////////////////////////////////////

	syncInstance.RunChannelsExample()
}
